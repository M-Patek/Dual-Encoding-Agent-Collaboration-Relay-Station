import time
import sys
import os
from playwright.sync_api import sync_playwright, Page, TimeoutError as PlaywrightTimeoutError, expect

# =======================================================================================
# === I. 阶段零：前置依赖与全局常量规范 (Phase Zero: Dependencies & Constants) ===
# =======================================================================================

# ----------------- 协作常量 (Collaboration Constants) -----------------
TERMINATION_PHRASE = "TASK_COMPLETED_SUCCESSFULLY"
START_CMD_MSG = "请启动双编码协作流程并开始您的协调任务。"

# ----------------- UI 定位器常量 (UI Locator Constants) -----------------
# 【2025-10-20 极致拟人最终版】
INPUT_SEL = 'div[role="textbox"]'
USER_QUERY_SEL = '.user-query'
MODEL_RESPONSE_CONTAINER_SEL = '.response-container'
LATEST_MSG_SEL = f'{USER_QUERY_SEL}, {MODEL_RESPONSE_CONTAINER_SEL}'
MODEL_RESPONSE_SHELL_SEL = '.model-response'
LATEST_MSG_SEL_FOR_WAITING = f'{USER_QUERY_SEL}, {MODEL_RESPONSE_SHELL_SEL}'
RESPONSE_CONTENT_SEL = '.response-content'
DONE_STATUS_SEL = 'button[aria-label="停止回复"], button[aria-label="Stop responding"]'
SEND_BUTTON_SEL = 'button mat-icon[data-mat-icon-name="send"]'
# ---------------------------------------------------------------------------------------


# =======================================================================================
# === II. 阶段一：核心功能函数封装 (Phase One: Core Function Wrappers) ===
# =======================================================================================

def log(level: str, message: str, step: str = "ORCHESTRATOR"):
    """记录带有时间戳、级别和步骤信息的标准化日志。"""
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}][{level:<7}][{step:<15}] {message}")

def wait_for_page_stability(page: Page, agent_name: str):
    """等待页面加载完成并稳定。"""
    TIMEOUT_MS = 30000
    log("INFO", f"等待 {agent_name} 页面稳定 (超时 {TIMEOUT_MS//1000}s)...", "PAGE_WAIT")
    try:
        expect(page.locator(INPUT_SEL)).to_be_visible(timeout=TIMEOUT_MS)
        log("SUCCESS", f"{agent_name} 页面已稳定，输入框可见。", "PAGE_WAIT")
    except PlaywrightTimeoutError:
        log("FATAL", f"{agent_name} 页面稳定失败，未找到核心输入框。", "PAGE_WAIT")
        raise Exception("页面初始化失败，无法继续。")

def handle_termination(final_message: str):
    """处理终止信号并安全退出。"""
    log("SUCCESS", "发现终止信号。任务完成，程序即将退出。", "TERMINATION")
    log("INFO", f"Agent A 的最终交付内容:\n---\n{final_message}\n---", "TERMINATION")
    log("INFO", "浏览器将保持打开状态，请检查最终结果。", "TERMINATION")
    sys.exit(0)

def send_message_robust(page: Page, message: str, agent_name: str) -> int:
    """
    核心发送函数（v11.0 - 极致拟人）：
    最终解决方案。通过模拟粘贴、鼠标悬停、人类延迟和点击按钮，
    最大程度地模仿真实用户操作，以期绕过最深层的反自动化机制。
    """
    if not message or not message.strip():
        log("WARNING", f"尝试发送给 {agent_name} 的消息为空，已跳过。", "SEND_ROBUST")
        return page.locator(LATEST_MSG_SEL_FOR_WAITING).count()

    log("INFO", f"向 {agent_name} 发送消息 (长度: {len(message)})...", "SEND_ROBUST")
    try:
        page.bring_to_front()
        
        count_before = page.locator(LATEST_MSG_SEL_FOR_WAITING).count()
        log("INFO", f"发送前检测到气泡数: {count_before}", "SEND_ROBUST")

        input_locator = page.locator(INPUT_SEL)
        send_button_locator = page.locator(SEND_BUTTON_SEL)
        
        # 步骤1: 模拟粘贴
        input_locator.fill("")
        page.evaluate("text => navigator.clipboard.writeText(text)", message)
        input_locator.press("Control+V")
        log("INFO", "内容已粘贴。", "SEND_ROBUST")
        
        # 步骤2: 模拟人类反应延迟
        page.wait_for_timeout(500)

        # 步骤3: 模拟鼠标移动到按钮上
        send_button_locator.hover()
        log("INFO", "鼠标已悬停在发送按钮上。", "SEND_ROBUST")
        page.wait_for_timeout(200)

        # 步骤4: 点击按钮
        send_button_locator.click()
        log("INFO", f"消息已通过点击按钮提交给 {agent_name}。", "SEND_ROBUST")

        # 步骤5: 使用终极裁决进行等待
        log("INFO", f"请求浏览器进行终极裁决...", "SEND_ROBUST")
        js_wait_expression = """
            (args) => {
                const [selector, known_count] = args;
                const current_elements = document.querySelectorAll(selector);
                // 裁决条件：元素数量大于发送前，或者元素数量虽然没变多但最后一个元素的内容已改变
                // （后者逻辑复杂，暂时只用前者）
                return current_elements.length > known_count;
            }
        """
        page.wait_for_function(js_wait_expression, [LATEST_MSG_SEL_FOR_WAITING, count_before], timeout=60000)
        log("SUCCESS", "浏览器裁决：新气泡已生成！发送成功。", "SEND_ROBUST")

        time.sleep(1)
        new_len = page.locator(LATEST_MSG_SEL).count()
        return new_len

    except Exception as e:
        log("FATAL", f"向 {agent_name} 发送消息时发生致命错误: {e}", "SEND_ROBUST")
        raise

def get_latest_message_safe(page: Page, agent_name: str) -> tuple[str, int]:
    """核心提取函数：等待AI生成完毕，然后提取内容。"""
    log("INFO", f"等待 {agent_name} 生成内容...", "GET_SAFE")
    try:
        expect(page.locator(DONE_STATUS_SEL)).to_be_hidden(timeout=120000)
        log("SUCCESS", f"{agent_name} 已完成生成。", "GET_SAFE")
    except PlaywrightTimeoutError:
        log("WARNING", f"{agent_name} 生成时间超过 120s，强制提取内容。", "GET_SAFE")

    try:
        last_message_container = page.locator(LATEST_MSG_SEL).last
        
        if last_message_container.locator(RESPONSE_CONTENT_SEL).count() > 0:
            text_locator = last_message_container.locator(RESPONSE_CONTENT_SEL)
        else:
            text_locator = last_message_container

        expect(text_locator).to_be_visible(timeout=10000)
        message_text = text_locator.inner_text().strip()
        new_len = page.locator(LATEST_MSG_SEL).count()
        
        log("SUCCESS", f"成功提取 {agent_name} 的消息。新历史记录数: {new_len}", "GET_SAFE")
        return message_text, new_len
        
    except Exception as e:
        log("FATAL", f"无法从 {agent_name} 提取最新消息: {e}", "GET_SAFE")
        raise

def wait_for_response_loop(page: Page, current_len: int, agent_name: str) -> int:
    """核心等待函数：使用“终极裁决”等待AI的回复。"""
    TIMEOUT_LOOP_SEC = 180
    log("INFO", f"等待 {agent_name} 回复 (当前轮数: {current_len}, 超时: {TIMEOUT_LOOP_SEC}s)...", "WAIT_LOOP")
    
    try:
        js_wait_expression = """
            (args) => {
                const [selector, known_count] = args;
                return document.querySelectorAll(selector).length > known_count;
            }
        """
        page.wait_for_function(js_wait_expression, [LATEST_MSG_SEL_FOR_WAITING, current_len], timeout=TIMEOUT_LOOP_SEC * 1000)
        
        log("SUCCESS", "浏览器裁决：AI已回复！", "WAIT_LOOP")
        
        time.sleep(1)
        new_len = page.locator(LATEST_MSG_SEL).count()
        return new_len

    except Exception as e:
        log("FATAL", f"等待 {agent_name} 回复时发生致命错误: {e}", "WAIT_LOOP_ERROR")
        raise e

# =======================================================================================
# === III. 阶段二：主编排逻辑 (Phase Two: Main Orchestration Logic) ===
# =======================================================================================

def run_orchestrator(page_A: Page, page_B: Page):
    """主程序入口，包含启动逻辑检查和核心协作循环。"""
    log("INFO", "=== 自动化流程正式开始 ===", "MAIN")

    len_A = page_A.locator(LATEST_MSG_SEL_FOR_WAITING).count()
    if len_A == 0:
        log("INFO", "场景1: A页面空白。发送启动指令...", "SCENE_HANDLER")
        len_A = send_message_robust(page_A, START_CMD_MSG, "Agent A")
        len_A = wait_for_response_loop(page_A, 1, "Agent A")
    
    elif len_A > 0 and len_A % 2 != 0:
        log("INFO", "场景2: 用户已提问，等待A的回复...", "SCENE_HANDLER")
        len_A = wait_for_response_loop(page_A, len_A, "Agent A")

    log("INFO", "状态同步完成。进入主协作循环。", "SCENE_HANDLER")

    while True:
        log("INFO", "--- 开始新一轮协作 ---", "CYCLE")

        message_A, len_A = get_latest_message_safe(page_A, "Agent A")
        if TERMINATION_PHRASE in message_A:
            handle_termination(message_A)
        
        len_B = send_message_robust(page_B, message_A, "Agent B")
        len_B = wait_for_response_loop(page_B, len_A + 1, "Agent B")

        message_B, len_B = get_latest_message_safe(page_B, "Agent B")
        len_A = send_message_robust(page_A, message_B, "Agent A")
        len_A = wait_for_response_loop(page_A, len_B + 1, "Agent A")
        
        log("SUCCESS", "--- 本轮协作完成 ---", "CYCLE")

# =======================================================================================
# === IV. 阶段三：程序入口与浏览器设置 (Phase Three: Entry Point & Browser Setup) ===
# =======================================================================================
if __name__ == '__main__':
    try:
        EDGE_USER_DATA_PATH = "C:\\Users\\asus\\AppData\\Local\\Microsoft\\Edge\\User Data"
        if not os.path.exists(EDGE_USER_DATA_PATH):
            raise FileNotFoundError(f"Edge 用户数据目录不存在: {EDGE_USER_DATA_PATH}")

        GEMINI_URL_A = "https://gemini.google.com/u/1/app?hl=zh-cn"
        GEMINI_URL_B = "https://gemini.google.com/u/3/app?hl=zh-cn"
        
        with sync_playwright() as p:
            log("INFO", "启动 Edge 浏览器 (使用您的个人配置)...", "SETUP")
            context = p.chromium.launch_persistent_context(
                user_data_dir=EDGE_USER_DATA_PATH,
                headless=False,
                channel="msedge",
                slow_mo=50,
                args=['--start-maximized']
            )
            
            page_A = context.pages[0] if context.pages else context.new_page()
            page_A.goto(GEMINI_URL_A, wait_until="domcontentloaded", timeout=90000)
            
            page_B = context.new_page()
            page_B.goto(GEMINI_URL_B, wait_until="domcontentloaded", timeout=90000)
            
            log("SUCCESS", "双 Agent 页面已加载。", "SETUP")
            page_A.bring_to_front()

            MANUAL_SETUP_TIME = 30
            log("WARNING", f"您有 {MANUAL_SETUP_TIME} 秒时间进行手动设置。", "MANUAL_SETUP")
            log("WARNING", "请在 Agent A (第一个标签页) 中输入您的初始任务。", "MANUAL_SETUP")
            
            for i in range(MANUAL_SETUP_TIME, 0, -10):
                log("INFO", f"剩余时间: {i} 秒...", "MANUAL_SETUP")
                time.sleep(10)

            run_orchestrator(page_A=page_A, page_B=page_B)

    except FileNotFoundError as e:
        log("FATAL", str(e), "SETUP_ERROR")
    except Exception as e:
        log("FATAL", f"脚本因未知错误而终止: {e}", "RUNTIME_ERROR")
    finally:
        log("INFO", "脚本执行结束。", "SHUTDOWN")
        input("按 Enter 键关闭浏览器...")
