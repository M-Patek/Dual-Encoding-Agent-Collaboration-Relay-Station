import time
import sys
import random
import os
from playwright.sync_api import sync_playwright, Page, TimeoutError as PlaywrightTimeoutError, expect

# =======================================================================================
# === I. 阶段零：前置依赖与全局常量规范 (Phase Zero: Dependencies & Constants) ===
# =======================================================================================

# ----------------- 协作常量 (Collaboration Constants) -----------------
TERMINATION_PHRASE = "TASK_COMPLETED_SUCCESSFULLY"
START_CMD_MSG = "请启动双编码协作流程并开始您的协调任务。"

# ----------------- UI 定位器常量 (UI Locator Constants) -----------------
# 【2025-10-20 极致拟人最终版】
INPUT_SEL = 'div[role="textbox"]'
USER_QUERY_SEL = '.user-query'
MODEL_RESPONSE_CONTAINER_SEL = '.response-container'
LATEST_MSG_SEL = f'{USER_QUERY_SEL}, {MODEL_RESPONSE_CONTAINER_SEL}'
MODEL_RESPONSE_SHELL_SEL = '.model-response'
LATEST_MSG_SEL_FOR_WAITING = f'{USER_QUERY_SEL}, {MODEL_RESPONSE_SHELL_SEL}'
RESPONSE_CONTENT_SEL = '.response-content'
DONE_STATUS_SEL = 'button[aria-label="停止回复"], button[aria-label="Stop responding"]'
SEND_BUTTON_SEL = 'button mat-icon[data-mat-icon-name="send"]'
# ---------------------------------------------------------------------------------------


# =======================================================================================
# === Ib. 阶段零-B：全局配置 (Phase Zero-B: Global Configuration) =====================
# =======================================================================================
class Config:
    """集中管理所有可配置的全局变量。"""
    # --- 浏览器与用户数据配置 ---
    EDGE_USER_DATA_PATH = "C:\\Users\\asus\\AppData\\Local\\Microsoft\\Edge\\User Data"
    
    # --- 目标页面URL ---
    GEMINI_URL_A = "https://gemini.google.com/u/1/app?hl=zh-cn"
    GEMINI_URL_B = "https://gemini.google.com/u/3/app?hl=zh-cn"

    class Timeouts:
        """集中管理所有超时和延迟相关的常量（单位：毫秒或秒）。"""
        PAGE_LOAD_MS = 90000
        PAGE_STABILITY_MS = 30000
        AI_GENERATION_MS = 120000
        RESPONSE_VISIBILITY_MS = 10000
        SEND_ROBUST_WAIT_MS = 60000
        RESPONSE_LOOP_SEC = 180
        MANUAL_SETUP_SEC = 30

# =======================================================================================
# === II. 阶段一：核心功能函数封装 (Phase One: Core Function Wrappers) ===
# =======================================================================================

def _wait_for_new_message_bubble(page: Page, known_count: int, timeout: int, agent_name: str):
    """(Internal Helper) Waits for a new message bubble to appear using a JS function."""
    log("INFO", f"Waiting for new message from {agent_name} (known count: {known_count}, timeout: {timeout/1000}s)...", "JS_WAIT")
    js_wait_expression = """
        (args) => {
            const [selector, count] = args;
            return document.querySelectorAll(selector).length > count;
        }
    """
    page.wait_for_function(js_wait_expression, [LATEST_MSG_SEL_FOR_WAITING, known_count], timeout=timeout)

def log(level: str, message: str, step: str = "ORCHESTRATOR"):
    """记录带有时间戳、级别和步骤信息的标准化日志。"""
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}][{level:<7}][{step:<15}] {message}")

def wait_for_page_stability(page: Page, agent_name: str):
    """等待页面加载完成并稳定。"""
    log("INFO", f"等待 {agent_name} 页面稳定 (超时 {Config.Timeouts.PAGE_STABILITY_MS//1000}s)...", "PAGE_WAIT")
    try:
        expect(page.locator(INPUT_SEL)).to_be_visible(timeout=Config.Timeouts.PAGE_STABILITY_MS)
        log("SUCCESS", f"{agent_name} 页面已稳定，输入框可见。", "PAGE_WAIT")
    except PlaywrightTimeoutError:
        log("FATAL", f"{agent_name} 页面稳定失败，未找到核心输入框。", "PAGE_WAIT")
        raise Exception("页面初始化失败，无法继续。")

def _move_mouse_human_like(page: Page, target_locator):
    """(Internal Helper) Moves the mouse to a target locator using a Bezier curve."""
    log("INFO", "Simulating human-like mouse movement...", "MOUSE_MOVE")
    
    start_point = page.mouse.position
    if not start_point:
        # Fallback if the mouse position isn't available (e.g., first action)
        start_point = {'x': random.randint(0, 100), 'y': random.randint(0, 100)}

    target_box = target_locator.bounding_box()
    if not target_box:
        log("WARNING", "Could not get bounding box for mouse movement target.", "MOUSE_MOVE")
        return

    end_point = {'x': target_box['x'] + target_box['width'] / 2, 'y': target_box['y'] + target_box['height'] / 2}

    # Simple linear interpolation for now, as full Bezier is complex without libraries
    steps = 20
    for i in range(steps + 1):
        progress = i / steps
        x = start_point['x'] + (end_point['x'] - start_point['x']) * progress
        y = start_point['y'] + (end_point['y'] - start_point['y']) * progress
        page.mouse.move(x, y)
        page.wait_for_timeout(random.uniform(5, 15))

def handle_termination(final_message: str):
    """处理终止信号并安全退出。"""
    log("SUCCESS", "发现终止信号。任务完成，程序即将退出。", "TERMINATION")
    log("INFO", f"Agent A 的最终交付内容:\n---\n{final_message}\n---", "TERMINATION")
    log("INFO", "浏览器将保持打开状态，请检查最终结果。", "TERMINATION")
    sys.exit(0)

def send_message_robust(page: Page, message: str, agent_name: str) -> int:
    """
    核心发送函数（v12.0 - 极致拟人）：
    通过模拟人类打字、鼠标移动、随机延迟和点击按钮，
    最大程度地模仿真实用户操作，以期绕过最深层的反自动化机制。
    """
    if not message or not message.strip():
        log("WARNING", f"尝试发送给 {agent_name} 的消息为空，已跳过。", "SEND_ROBUST")
        return page.locator(LATEST_MSG_SEL_FOR_WAITING).count()

    log("INFO", f"向 {agent_name} 发送消息 (长度: {len(message)})...", "SEND_ROBUST")
    try:
        page.bring_to_front()
        
        count_before = page.locator(LATEST_MSG_SEL_FOR_WAITING).count()
        log("INFO", f"发送前检测到气泡数: {count_before}", "SEND_ROBUST")

        input_box = page.locator(INPUT_SEL)
        send_button_locator = page.locator(SEND_BUTTON_SEL)
        
        # 步骤1: 模拟人类打字行为
        input_box.click()
        log("INFO", "开始模拟打字...", "SEND_ROBUST")
        for char in message:
            input_box.type(char, delay=random.uniform(50, 150))
        log("INFO", "内容已输入。", "SEND_ROBUST")
        
        # 步骤2: 模拟人类反应延迟
        page.wait_for_timeout(random.uniform(300, 700))

        # 步骤3: 模拟鼠标移动到按钮上
        _move_mouse_human_like(page, send_button_locator)
        send_button_locator.hover()
        log("INFO", "鼠标已悬停在发送按钮上。", "SEND_ROBUST")
        page.wait_for_timeout(random.uniform(100, 300))

        # 步骤4: 点击按钮
        send_button_locator.click()

        # 步骤5: 使用终极裁决进行等待
        _wait_for_new_message_bubble(page, count_before, Config.Timeouts.SEND_ROBUST_WAIT_MS, agent_name)
        log("SUCCESS", "浏览器裁决：新气泡已生成！发送成功。", "SEND_ROBUST")

        new_len = page.locator(LATEST_MSG_SEL).count()
        return new_len

    except Exception as e:
        log("FATAL", f"向 {agent_name} 发送消息时发生致命错误: {e}", "SEND_ROBUST")
        raise

def get_latest_message_safe(page: Page, agent_name: str) -> tuple[str, int]:
    """核心提取函数：等待AI生成完毕，然后提取内容。"""
    log("INFO", f"等待 {agent_name} 生成内容...", "GET_SAFE")
    try:
        expect(page.locator(DONE_STATUS_SEL)).to_be_hidden(timeout=Config.Timeouts.AI_GENERATION_MS)
        log("SUCCESS", f"{agent_name} 已完成生成。", "GET_SAFE")
    except PlaywrightTimeoutError:
        log("WARNING", f"{agent_name} 生成时间超过 {Config.Timeouts.AI_GENERATION_MS/1000}s，强制提取内容。", "GET_SAFE")

    try:
        last_message_container = page.locator(LATEST_MSG_SEL).last
        
        if last_message_container.locator(RESPONSE_CONTENT_SEL).count() > 0:
            text_locator = last_message_container.locator(RESPONSE_CONTENT_SEL)
        else:
            text_locator = last_message_container

        expect(text_locator).to_be_visible(timeout=Config.Timeouts.RESPONSE_VISIBILITY_MS)
        message_text = text_locator.inner_text().strip()
        new_len = page.locator(LATEST_MSG_SEL).count()
        
        log("SUCCESS", f"成功提取 {agent_name} 的消息。新历史记录数: {new_len}", "GET_SAFE")
        return message_text, new_len
        
    except Exception as e:
        log("FATAL", f"无法从 {agent_name} 提取最新消息: {e}", "GET_SAFE")
        raise

def wait_for_response_loop(page: Page, current_len: int, agent_name: str) -> int:
    """核心等待函数：使用“终极裁决”等待AI的回复。"""
    log("INFO", f"等待 {agent_name} 回复 (当前轮数: {current_len}, 超时: {Config.Timeouts.RESPONSE_LOOP_SEC}s)...", "WAIT_LOOP")
    try:
        _wait_for_new_message_bubble(page, current_len, Config.Timeouts.RESPONSE_LOOP_SEC * 1000, agent_name)
        log("SUCCESS", "浏览器裁决：AI已回复！", "WAIT_LOOP")
        new_len = page.locator(LATEST_MSG_SEL).count()
        return new_len
    except Exception as e:
        log("FATAL", f"等待 {agent_name} 回复时发生致命错误: {e}", "WAIT_LOOP_ERROR")
        raise e

# =======================================================================================
# === III. 阶段二：主编排逻辑 (Phase Two: Main Orchestration Logic) ===
# =======================================================================================

def run_orchestrator(page_A: Page, page_B: Page):
    """主程序入口，包含启动逻辑检查和核心协作循环。"""
    log("INFO", "=== 自动化流程正式开始 ===", "MAIN")

    len_A = page_A.locator(LATEST_MSG_SEL_FOR_WAITING).count()
    if len_A == 0:
        log("INFO", "场景1: A页面空白。发送启动指令...", "SCENE_HANDLER")
        len_A = send_message_robust(page_A, START_CMD_MSG, "Agent A")
        len_A = wait_for_response_loop(page_A, len_A, "Agent A")
    
    elif len_A > 0 and len_A % 2 != 0:
        log("INFO", "场景2: 用户已提问，等待A的回复...", "SCENE_HANDLER")
        len_A = wait_for_response_loop(page_A, len_A, "Agent A")

    log("INFO", "状态同步完成。进入主协作循环。", "SCENE_HANDLER")

    while True:
        log("INFO", "--- 开始新一轮协作 ---", "CYCLE")

        message_A, _ = get_latest_message_safe(page_A, "Agent A")
        if TERMINATION_PHRASE in message_A:
            handle_termination(message_A)
        
        count_B_after_send = send_message_robust(page_B, message_A, "Agent B")
        wait_for_response_loop(page_B, count_B_after_send, "Agent B")

        message_B, _ = get_latest_message_safe(page_B, "Agent B")
        count_A_after_send = send_message_robust(page_A, message_B, "Agent A")
        wait_for_response_loop(page_A, count_A_after_send, "Agent A")
        
        log("SUCCESS", "--- 本轮协作完成 ---", "CYCLE")

# =======================================================================================
# === IV. 阶段三：程序入口与浏览器设置 (Phase Three: Entry Point & Browser Setup) ===
# =======================================================================================
if __name__ == '__main__':
    try:
        if not os.path.exists(Config.EDGE_USER_DATA_PATH):
            raise FileNotFoundError(f"Edge 用户数据目录不存在: {Config.EDGE_USER_DATA_PATH}")
        
        with sync_playwright() as p:
            log("INFO", "启动 Edge 浏览器 (使用您的个人配置)...", "SETUP")
            context = p.chromium.launch_persistent_context(
                user_data_dir=Config.EDGE_USER_DATA_PATH,
                headless=False,
                channel="msedge",
                slow_mo=50,
                args=['--start-maximized', '--disable-blink-features=AutomationControlled']
            )
            
            page_A = context.pages[0] if context.pages else context.new_page()
            page_A.goto(Config.GEMINI_URL_A, wait_until="domcontentloaded", timeout=Config.Timeouts.PAGE_LOAD_MS)
            
            page_B = context.new_page()
            page_B.goto(Config.GEMINI_URL_B, wait_until="domcontentloaded", timeout=Config.Timeouts.PAGE_LOAD_MS)
            
            log("SUCCESS", "双 Agent 页面已加载。", "SETUP")
            page_A.bring_to_front()

            log("WARNING", f"您有 {Config.Timeouts.MANUAL_SETUP_SEC} 秒时间进行手动设置。", "MANUAL_SETUP")
            log("WARNING", "请在 Agent A (第一个标签页) 中输入您的初始任务。", "MANUAL_SETUP")
            
            for i in range(Config.Timeouts.MANUAL_SETUP_SEC, 0, -10):
                log("INFO", f"剩余时间: {i} 秒...", "MANUAL_SETUP")
                time.sleep(10)

            run_orchestrator(page_A=page_A, page_B=page_B)

    except FileNotFoundError as e:
        log("FATAL", str(e), "SETUP_ERROR")
    except Exception as e:
        log("FATAL", f"脚本因未知错误而终止: {e}", "RUNTIME_ERROR")
    finally:
        log("INFO", "脚本执行结束。", "SHUTDOWN")
        input("按 Enter 键关闭浏览器...")
